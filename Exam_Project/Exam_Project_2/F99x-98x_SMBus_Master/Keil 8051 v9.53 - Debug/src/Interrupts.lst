C51 COMPILER V9.53.0.0   INTERRUPTS                                                        04/26/2018 14:17:25 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE INTERRUPTS
OBJECT MODULE PLACED IN .\src\Interrupts.OBJ
COMPILER INVOKED BY: c:\SiliconLabs\SimplicityStudio\v4\developer\toolchains\keil_8051\9.53\BIN\C51.exe C:\Users\Rilind\
                    -Desktop\System_project\Exam_Project\Exam_Project_2\F99x-98x_SMBus_Master\src\Interrupts.c OMF2 SMALL DEBUG OBJECTEXTEND 
                    -ROM(LARGE) WARNINGLEVEL(2) FLOATFUZZY(3) OPTIMIZE(8,SPEED) DEFINE(DEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(C:/Users/
                    -Rilind/Desktop/System_project/Exam_Project/Exam_Project_2/F99x-98x_SMBus_Master/inc;C:/SiliconLabs/SimplicityStudio/v4/d
                    -eveloper/sdks/8051/v4.1.1//Device/shared/si8051base;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.1//Devic
                    -e/C8051F990/inc) PRINT(.\src\Interrupts.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\src\Interrupts.OBJ)

line level    source

   1          //=========================================================
   2          // src/Interrupts.c: generated by Hardware Configurator
   3          //
   4          // This file will be regenerated when saving a document.
   5          // leave the sections inside the "$[...]" comment tags alone
   6          // or they will be overwritten!
   7          //=========================================================
   8          
   9          
  10          // USER INCLUDES
  11          #include <SI_C8051F990_Register_Enums.h>
  12          #include "F99x_SMBus_Master.h"
  13          
  14          //-----------------------------------------------------------------------------
  15          // Global CONSTANTS
  16          //-----------------------------------------------------------------------------
  17          
  18          #define  SYSCLK         24500000       // System clock frequency in Hz
  19          
  20          
  21          #define  SMB_FREQUENCY  10000          // Target SCL clock rate
  22          // This example supports between 10kHz
  23          // and 100kHz
  24          
  25          #define  WRITE          0x00           // SMBus WRITE command
  26          #define  READ           0x01           // SMBus READ command
  27          
  28          #define LED_ON           0             // Turns the LED on
  29          #define LED_OFF          1             // Turns the LED off
  30          
  31          
  32          // Status vector - top 4 bits only
  33          #define  SMB_MTSTA      0xE0           // (MT) start transmitted
  34          #define  SMB_MTDB       0xC0           // (MT) data byte transmitted
  35          #define  SMB_MRDB       0x80           // (MR) data byte received
  36          volatile U8 ADDR_SEND ;
  37          // End status vector definition
  38          
  39          //-----------------------------------------------------------------------------
  40          // SMBUS0_ISR
  41          //-----------------------------------------------------------------------------
  42          //
  43          // SMBUS0 ISR Content goes here. Remember to clear flag bits:
  44          // SMB0CN::SI (SMBus Interrupt Flag)
  45          //
  46          //-----------------------------------------------------------------------------
  47          INTERRUPT (SMBUS0_ISR, SMBUS0_IRQn)
  48          {
  49   1              bit FAIL = 0;                       // Used by the ISR to flag failed
  50   1              // transfers
  51   1              // ADDR_SEND = 0;           // Used by the ISR to flag byte
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        04/26/2018 14:17:25 PAGE 2   

  52   1              // transmissions as slave addresses
  53   1      
  54   1              if (SMB0CN_ARBLOST == 0)                   // Check for errors
  55   1              {
  56   2                      // Normal operation
  57   2                      switch (SMB0CN & 0xF0)           // Status vector
  58   2                      {
  59   3                              // Master Transmitter/Receiver: START condition transmitted.
  60   3                      case SMB_MTSTA:
  61   3                              //if(START_SMB){
  62   3                              SMB0DAT = TARGET;          // Load address of the target slave
  63   3                              SMB0DAT &= 0xFE;           // Clear the LSB of the address for the
  64   3                              // R/W bit
  65   3                              SMB0DAT |= SMB_RW;         // Load R/W bit
  66   3                              SMB0CN_STA = 0;            // Manually clear START bit
  67   3                              ADDR_SEND = 1;
  68   3                              START_SMB=0;
  69   3                              //}
  70   3                              break;
  71   3      
  72   3                              // Master Transmitter: Data byte transmitted
  73   3                      case SMB_MTDB:
  74   3                              if (SMB0CN_ACK)                   // Slave SMB0CN_ACK?
  75   3                              {
  76   4                                      if (ADDR_SEND)          // If the previous byte was a slave
  77   4                                      {
  78   5                                              // UART_Send(ADDR_SEND);
  79   5                                              // UART_Send(ADDR_SEND);
  80   5                                              // Next byte is not a slave address
  81   5      
  82   5                                              if(CO2_MODE==1)
  83   5                                              {
  84   6                                                      if (SMB_RW == WRITE) // If this transfer is a WRITE,
  85   6                                                      {
  86   7                                                              if(length>0){
  87   8                                                              SMB0DAT=DATA_CO2_OUT[5-length];
  88   8                                                              length--;
  89   8                                                              }else{
  90   8                                                                      ADDR_SEND=0;
  91   8                                                              }
  92   7                                                      }
  93   6                                              }
  94   5                                              else if(CO2_MODE==0){
  95   6                                              if (SMB_RW == WRITE) // If this transfer is a WRITE,
  96   6                                              {
  97   7                                                      // send data byte
  98   7                                                      if(ADDR_SEND==1){
  99   8                                                              SMB0DAT = SMB_REG_OUT;
 100   8                                                      }
 101   7                                                      if(ADDR_SEND==2){
 102   8                                                              SMB0DAT = SMB_DATA_OUT;
 103   8                                                      }
 104   7      
 105   7                                              }
 106   6                                              if(ADDR_SEND==1){
 107   7                                                      ADDR_SEND = 2;
 108   7                                              }
 109   6                                              else if(ADDR_SEND==2){
 110   7                                                      ADDR_SEND = 0;
 111   7                                                      //UART_Send('x');
 112   7                                                      //      UART_Send('x');
 113   7                                              }
 114   6                                              if(RW_Reg==0){
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        04/26/2018 14:17:25 PAGE 3   

 115   7                                                      ADDR_SEND=0;
 116   7                                                      //UART_Send('x');
 117   7                                              }
 118   6      
 119   6                                              else {}              // If this transfer is a READ,
 120   6                                              }
 121   5                                              // proceed with transfer without
 122   5                                              // writing to SMB0DAT (switch
 123   5                                              // to receive mode)
 124   5                                      }
 125   4                                      else                    // If previous byte was not a slave
 126   4                                      {                       // address,
 127   5                                              //UART_Send('x');
 128   5                                              if(RW_Reg==1)
 129   5                                              SMB0CN_STO = 1;             // Set SMB0CN_STO to terminate transfer
 130   5                                              SMB_BUSY = 0;        // And free SMBus interface
 131   5                                      }
 132   4                              }
 133   3                              else                       // If slave NACK,
 134   3                              {
 135   4                                      SMB0CN_STO = 1;                // Send STOP condition, followed
 136   4                                      SMB0CN_STA = 1;                // By a START
 137   4                              }
 138   3                              break;
 139   3      
 140   3                              // Master Receiver: byte received
 141   3                      case SMB_MRDB:
 142   3                              if(CO2_MODE==2)
 143   3                              {
 144   4                                      if(length>0)
 145   4                                      {
 146   5                                              if(length==2){
 147   6                                                      DATA_CO2_IN = ((U16) SMB0DAT<<8);
 148   6                                              }else if (length==1){
 149   6                                                      DATA_CO2_IN = ((U16) SMB0DAT);
 150   6                                              }else{
 151   6                                                      //SMB_DATA_IN=SMB0DAT;
 152   6                                              }
 153   5                                              SMB0CN_ACK = 1;
 154   5                                              length--;
 155   5                                      }else{
 156   5                                              SMB_BUSY = 0;              // Free SMBus interface
 157   5                                              SMB0CN_ACK = 0;                   // Send NACK to indicate last byte
 158   5                                              SMB0CN_STO = 1;                   // Send STOP to terminate transfer
 159   5                                      }
 160   4      
 161   4                              }else{
 162   4                              SMB_DATA_IN = SMB0DAT;     // Store received byte
 163   4                              SMB_BUSY = 0;              // Free SMBus interface
 164   4                              SMB0CN_ACK = 0;                   // Send NACK to indicate last byte
 165   4                              SMB0CN_STO = 1;                   // Send STOP to terminate transfer
 166   4                              //UART_Send('a');
 167   4                              SMB0CN_STO = 1;             // Set SMB0CN_STO to terminate transfer
 168   4                              SMB_BUSY = 0;
 169   4                              }
 170   3                              break;
 171   3      
 172   3                      default:
 173   3                              FAIL = 1;                  // Indicate failed transfer
 174   3                              // and handle at end of ISR
 175   3                              break;
 176   3      
 177   3                      } // end switch
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        04/26/2018 14:17:25 PAGE 4   

 178   2              }
 179   1              else
 180   1              {
 181   2                      // SMB0CN_ARBLOST = 1, error occurred... abort transmission
 182   2                      FAIL = 1;
 183   2              } // end SMB0CN_ARBLOST if
 184   1      
 185   1              if (FAIL)                           // If the transfer failed,
 186   1              {
 187   2                      SMB0CF &= ~0x80;                 // Reset communication
 188   2                      SMB0CF |= 0x80;
 189   2                      SMB0CN_STA = 0;
 190   2                      SMB0CN_STO = 0;
 191   2                      SMB0CN_ACK = 0;
 192   2      
 193   2                      SMB_BUSY = 0;                    // Free SMBus
 194   2      
 195   2                      FAIL = 0;
 196   2                      // Indicate an error occurred
 197   2              }
 198   1      
 199   1              SMB0CN_SI = 0;                             // Clear interrupt flag
 200   1      }
 201          
 202          
 203          //-----------------------------------------------------------------------------
 204          // TIMER3_ISR
 205          //-----------------------------------------------------------------------------
 206          //
 207          // TIMER3 ISR Content goes here. Remember to clear flag bits:
 208          // TMR3CN::TF3H (Timer # High Byte Overflow Flag)
 209          // TMR3CN::TF3L (Timer # Low Byte Overflow Flag)
 210          //
 211          //-----------------------------------------------------------------------------
 212          INTERRUPT (TIMER3_ISR, TIMER3_IRQn)
 213          {
 214   1              SMB0CF &= ~0x80;                    // Disable SMBus
 215   1              SMB0CF |= 0x80;                     // Re-enable SMBus
 216   1              TMR3CN &= ~0x80;                    // Clear Timer3 interrupt-pending flag
 217   1              SMB0CN_STA = 0;
 218   1              SMB_BUSY = 0;                       // Free SMBus
 219   1      }
 220          
 221          
 222          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    298    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
