C51 COMPILER V9.53.0.0   INTERRUPTS                                                        04/20/2018 20:43:05 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE INTERRUPTS
OBJECT MODULE PLACED IN .\src\Interrupts.OBJ
COMPILER INVOKED BY: c:\SiliconLabs\SimplicityStudio\v4\developer\toolchains\keil_8051\9.53\BIN\C51.exe C:\Users\Rilind\
                    -Desktop\System_project\Exam_Project\Exam_Project_2\F99x-98x_SMBus_Master\src\Interrupts.c OMF2 SMALL DEBUG OBJECTEXTEND 
                    -ROM(LARGE) WARNINGLEVEL(2) FLOATFUZZY(3) OPTIMIZE(8,SPEED) DEFINE(DEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(C:/Users/
                    -Rilind/Desktop/System_project/Exam_Project/Exam_Project_2/F99x-98x_SMBus_Master/inc;C:/SiliconLabs/SimplicityStudio/v4/d
                    -eveloper/sdks/8051/v4.1.1//Device/shared/si8051base;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.1//Devic
                    -e/C8051F990/inc) PRINT(.\src\Interrupts.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\src\Interrupts.OBJ)

line level    source

   1          //=========================================================
   2          // src/Interrupts.c: generated by Hardware Configurator
   3          //
   4          // This file will be regenerated when saving a document.
   5          // leave the sections inside the "$[...]" comment tags alone
   6          // or they will be overwritten!
   7          //=========================================================
   8          
   9          
  10          // USER INCLUDES
  11          #include <SI_C8051F990_Register_Enums.h>
  12          #include "F99x_SMBus_Master.h"
  13          
  14          //-----------------------------------------------------------------------------
  15          // Global CONSTANTS
  16          //-----------------------------------------------------------------------------
  17          
  18          #define  SYSCLK         24500000       // System clock frequency in Hz
  19          
  20          
  21          #define  SMB_FREQUENCY  10000          // Target SCL clock rate
  22          // This example supports between 10kHz
  23          // and 100kHz
  24          
  25          #define  WRITE          0x00           // SMBus WRITE command
  26          #define  READ           0x01           // SMBus READ command
  27          
  28          #define LED_ON           0             // Turns the LED on
  29          #define LED_OFF          1             // Turns the LED off
  30          
  31          
  32          // Status vector - top 4 bits only
  33          #define  SMB_MTSTA      0xE0           // (MT) start transmitted
  34          #define  SMB_MTDB       0xC0           // (MT) data byte transmitted
  35          #define  SMB_MRDB       0x80           // (MR) data byte received
  36          volatile U8 ADDR_SEND ;
  37          // End status vector definition
  38          
  39          //-----------------------------------------------------------------------------
  40          // SMBUS0_ISR
  41          //-----------------------------------------------------------------------------
  42          //
  43          // SMBUS0 ISR Content goes here. Remember to clear flag bits:
  44          // SMB0CN::SI (SMBus Interrupt Flag)
  45          //
  46          //-----------------------------------------------------------------------------
  47          INTERRUPT (SMBUS0_ISR, SMBUS0_IRQn)
  48          {
  49   1              bit FAIL = 0;                       // Used by the ISR to flag failed
  50   1              // transfers
  51   1              // ADDR_SEND = 0;           // Used by the ISR to flag byte
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        04/20/2018 20:43:05 PAGE 2   

  52   1              // transmissions as slave addresses
  53   1      
  54   1              if (SMB0CN_ARBLOST == 0)                   // Check for errors
  55   1              {
  56   2                      // Normal operation
  57   2                      switch (SMB0CN & 0xF0)           // Status vector
  58   2                      {
  59   3                              // Master Transmitter/Receiver: START condition transmitted.
  60   3                      case SMB_MTSTA:
  61   3                              //if(START_SMB){
  62   3      
  63   3      
  64   3                              SMB0DAT = TARGET;          // Load address of the target slave
  65   3                              SMB0DAT &= 0xFE;           // Clear the LSB of the address for the
  66   3                              // R/W bit
  67   3                              SMB0DAT |= SMB_RW;         // Load R/W bit
  68   3                              SMB0CN_STA = 0;            // Manually clear START bit
  69   3                              ADDR_SEND = 1;
  70   3                              START_SMB=0;
  71   3                              //}
  72   3                              break;
  73   3      
  74   3                              // Master Transmitter: Data byte transmitted
  75   3                      case SMB_MTDB:
  76   3                              if (SMB0CN_ACK)                   // Slave SMB0CN_ACK?
  77   3                              {
  78   4                                      if (ADDR_SEND)          // If the previous byte was a slave
  79   4                                      {
  80   5                                              // UART_Send(ADDR_SEND);
  81   5                                              // UART_Send(ADDR_SEND);
  82   5                                              // Next byte is not a slave address
  83   5                                              if (SMB_RW == WRITE) // If this transfer is a WRITE,
  84   5                                              {
  85   6                                                      // send data byte
  86   6                                                      if(ADDR_SEND==1){
  87   7                                                              SMB0DAT = SMB_REG_OUT;
  88   7                                                      }
  89   6                                                      if(ADDR_SEND==2){
  90   7                                                              SMB0DAT = SMB_DATA_OUT;
  91   7                                                      }
  92   6      
  93   6                                              }
  94   5                                              if(ADDR_SEND==1){
  95   6                                                      ADDR_SEND = 2;
  96   6                                              }
  97   5                                              else if(ADDR_SEND==2){
  98   6                                                      ADDR_SEND = 0;
  99   6                                                      //UART_Send('x');
 100   6                                                      //      UART_Send('x');
 101   6                                              }
 102   5                                              if(RW_Reg==0){
 103   6                                                      ADDR_SEND=0;
 104   6                                                      //UART_Send('x');
 105   6                                              }
 106   5      
 107   5                                              else {}              // If this transfer is a READ,
 108   5                                              // proceed with transfer without
 109   5                                              // writing to SMB0DAT (switch
 110   5                                              // to receive mode)
 111   5                                      }
 112   4                                      else                    // If previous byte was not a slave
 113   4                                      {                       // address,
 114   5                                              //UART_Send('x');
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        04/20/2018 20:43:05 PAGE 3   

 115   5                                              if(RW_Reg==1)
 116   5                                              SMB0CN_STO = 1;             // Set SMB0CN_STO to terminate transfer
 117   5                                              SMB_BUSY = 0;        // And free SMBus interface
 118   5                                      }
 119   4                              }
 120   3                              else                       // If slave NACK,
 121   3                              {
 122   4                                      SMB0CN_STO = 1;                // Send STOP condition, followed
 123   4                                      SMB0CN_STA = 1;                // By a START
 124   4                              }
 125   3                              break;
 126   3      
 127   3                              // Master Receiver: byte received
 128   3                      case SMB_MRDB:
 129   3                              SMB_DATA_IN = SMB0DAT;     // Store received byte
 130   3                              SMB_BUSY = 0;              // Free SMBus interface
 131   3                              SMB0CN_ACK = 0;                   // Send NACK to indicate last byte
 132   3                              SMB0CN_STO = 1;                   // Send STOP to terminate transfer
 133   3                              //UART_Send('a');
 134   3                              SMB0CN_STO = 1;             // Set SMB0CN_STO to terminate transfer
 135   3                              SMB_BUSY = 0;
 136   3                              break;
 137   3      
 138   3                      default:
 139   3                              FAIL = 1;                  // Indicate failed transfer
 140   3                              // and handle at end of ISR
 141   3                              break;
 142   3      
 143   3                      } // end switch
 144   2              }
 145   1              else
 146   1              {
 147   2                      // SMB0CN_ARBLOST = 1, error occurred... abort transmission
 148   2                      FAIL = 1;
 149   2              } // end SMB0CN_ARBLOST if
 150   1      
 151   1              if (FAIL)                           // If the transfer failed,
 152   1              {
 153   2                      SMB0CF &= ~0x80;                 // Reset communication
 154   2                      SMB0CF |= 0x80;
 155   2                      SMB0CN_STA = 0;
 156   2                      SMB0CN_STO = 0;
 157   2                      SMB0CN_ACK = 0;
 158   2      
 159   2                      SMB_BUSY = 0;                    // Free SMBus
 160   2      
 161   2                      FAIL = 0;
 162   2                      // Indicate an error occurred
 163   2              }
 164   1      
 165   1              SMB0CN_SI = 0;                             // Clear interrupt flag
 166   1      }
 167          
 168          
 169          //-----------------------------------------------------------------------------
 170          // TIMER3_ISR
 171          //-----------------------------------------------------------------------------
 172          //
 173          // TIMER3 ISR Content goes here. Remember to clear flag bits:
 174          // TMR3CN::TF3H (Timer # High Byte Overflow Flag)
 175          // TMR3CN::TF3L (Timer # Low Byte Overflow Flag)
 176          //
 177          //-----------------------------------------------------------------------------
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        04/20/2018 20:43:05 PAGE 4   

 178          INTERRUPT (TIMER3_ISR, TIMER3_IRQn)
 179          {
 180   1              SMB0CF &= ~0x80;                    // Disable SMBus
 181   1              SMB0CF |= 0x80;                     // Re-enable SMBus
 182   1              TMR3CN &= ~0x80;                    // Clear Timer3 interrupt-pending flag
 183   1              SMB0CN_STA = 0;
 184   1              SMB_BUSY = 0;                       // Free SMBus
 185   1      }
 186          
 187          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    186    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
