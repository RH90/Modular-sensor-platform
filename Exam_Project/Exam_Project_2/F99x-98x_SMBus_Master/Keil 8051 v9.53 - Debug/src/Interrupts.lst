C51 COMPILER V9.53.0.0   INTERRUPTS                                                        04/08/2018 18:14:15 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE INTERRUPTS
OBJECT MODULE PLACED IN .\src\Interrupts.OBJ
COMPILER INVOKED BY: c:\SiliconLabs\SimplicityStudio\v4\developer\toolchains\keil_8051\9.53\BIN\C51.exe C:\Users\Rilind\
                    -Desktop\System_project\Exam_Project\Exam_Project_2\F99x-98x_SMBus_Master\src\Interrupts.c OMF2 SMALL DEBUG OBJECTEXTEND 
                    -ROM(LARGE) WARNINGLEVEL(2) FLOATFUZZY(3) OPTIMIZE(8,SPEED) DEFINE(DEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(C:/Users/
                    -Rilind/Desktop/System_project/Exam_Project/Exam_Project_2/F99x-98x_SMBus_Master/inc;C:/SiliconLabs/SimplicityStudio/v4/d
                    -eveloper/sdks/8051/v4.1.1//Device/shared/si8051base;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.1//Devic
                    -e/C8051F990/inc) PRINT(.\src\Interrupts.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\src\Interrupts.OBJ)

line level    source

   1          //=========================================================
   2          // src/Interrupts.c: generated by Hardware Configurator
   3          //
   4          // This file will be regenerated when saving a document.
   5          // leave the sections inside the "$[...]" comment tags alone
   6          // or they will be overwritten!
   7          //=========================================================
   8          
   9          
  10          // USER INCLUDES
  11          #include <SI_C8051F990_Register_Enums.h>
  12          #include "F99x_SMBus_Master.h"
  13          
  14          //-----------------------------------------------------------------------------
  15          // Global CONSTANTS
  16          //-----------------------------------------------------------------------------
  17          
  18          #define  SYSCLK         24500000       // System clock frequency in Hz
  19          
  20          
  21          #define  SMB_FREQUENCY  10000          // Target SCL clock rate
  22          // This example supports between 10kHz
  23          // and 100kHz
  24          
  25          #define  WRITE          0x00           // SMBus WRITE command
  26          #define  READ           0x01           // SMBus READ command
  27          
  28          #define LED_ON           0             // Turns the LED on
  29          #define LED_OFF          1             // Turns the LED off
  30          
  31          // Device addresses (7 bits, LSB is a don't care)
  32          #define  SLAVE_ADDR     0xF0           // Device address for slave target
*** WARNING C317 IN LINE 32 OF C:\Users\Rilind\Desktop\System_project\Exam_Project\Exam_Project_2\F99x-98x_SMBus_Master\
             -src\Interrupts.c: attempt to redefine macro 'SLAVE_ADDR'
  33          
  34          // Status vector - top 4 bits only
  35          #define  SMB_MTSTA      0xE0           // (MT) start transmitted
  36          #define  SMB_MTDB       0xC0           // (MT) data byte transmitted
  37          #define  SMB_MRDB       0x80           // (MR) data byte received
  38          volatile U8 ADDR_SEND ;
  39          // End status vector definition
  40          
  41          //-----------------------------------------------------------------------------
  42          // SMBUS0_ISR
  43          //-----------------------------------------------------------------------------
  44          //
  45          // SMBUS0 ISR Content goes here. Remember to clear flag bits:
  46          // SMB0CN::SI (SMBus Interrupt Flag)
  47          //
  48          //-----------------------------------------------------------------------------
  49          INTERRUPT (SMBUS0_ISR, SMBUS0_IRQn)
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        04/08/2018 18:14:15 PAGE 2   

  50          {
  51   1              bit FAIL = 0;                       // Used by the ISR to flag failed
  52   1              // transfers
  53   1              // ADDR_SEND = 0;           // Used by the ISR to flag byte
  54   1              // transmissions as slave addresses
  55   1      
  56   1              if (SMB0CN_ARBLOST == 0)                   // Check for errors
  57   1              {
  58   2                      // Normal operation
  59   2                      switch (SMB0CN & 0xF0)           // Status vector
  60   2                      {
  61   3                              // Master Transmitter/Receiver: START condition transmitted.
  62   3                      case SMB_MTSTA:
  63   3                              //if(START_SMB){
  64   3      
  65   3      
  66   3                              SMB0DAT = TARGET;          // Load address of the target slave
  67   3                              SMB0DAT &= 0xFE;           // Clear the LSB of the address for the
  68   3                              // R/W bit
  69   3                              SMB0DAT |= SMB_RW;         // Load R/W bit
  70   3                              SMB0CN_STA = 0;            // Manually clear START bit
  71   3                              ADDR_SEND = 1;
  72   3                              START_SMB=0;
  73   3                              //}
  74   3                              break;
  75   3      
  76   3                              // Master Transmitter: Data byte transmitted
  77   3                      case SMB_MTDB:
  78   3                              if (SMB0CN_ACK)                   // Slave SMB0CN_ACK?
  79   3                              {
  80   4                                      if (ADDR_SEND)          // If the previous byte was a slave
  81   4                                      {
  82   5                                              // UART_Send(ADDR_SEND);
  83   5                                              // UART_Send(ADDR_SEND);
  84   5                                              // Next byte is not a slave address
  85   5                                              if (SMB_RW == WRITE) // If this transfer is a WRITE,
  86   5                                              {
  87   6                                                      // send data byte
  88   6                                                      if(ADDR_SEND==1){
  89   7                                                              SMB0DAT = SMB_REG_OUT;
  90   7                                                      }
  91   6                                                      if(ADDR_SEND==2){
  92   7                                                              SMB0DAT = SMB_DATA_OUT;
  93   7                                                      }
  94   6      
  95   6                                              }
  96   5                                              if(ADDR_SEND==1){
  97   6                                                      ADDR_SEND = 2;
  98   6                                              }
  99   5                                              else if(ADDR_SEND==2){
 100   6                                                      ADDR_SEND = 0;
 101   6                                                      //UART_Send('x');
 102   6                                                      //      UART_Send('x');
 103   6                                              }
 104   5                                              if(RW_Reg==0){
 105   6                                                      ADDR_SEND=0;
 106   6                                                      //UART_Send('x');
 107   6                                              }
 108   5      
 109   5                                              else {}              // If this transfer is a READ,
 110   5                                              // proceed with transfer without
 111   5                                              // writing to SMB0DAT (switch
 112   5                                              // to receive mode)
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        04/08/2018 18:14:15 PAGE 3   

 113   5                                      }
 114   4                                      else                    // If previous byte was not a slave
 115   4                                      {                       // address,
 116   5                                              //UART_Send('x');
 117   5                                              if(RW_Reg==1)
 118   5                                              SMB0CN_STO = 1;             // Set SMB0CN_STO to terminate transfer
 119   5                                              SMB_BUSY = 0;        // And free SMBus interface
 120   5                                      }
 121   4                              }
 122   3                              else                       // If slave NACK,
 123   3                              {
 124   4                                      SMB0CN_STO = 1;                // Send STOP condition, followed
 125   4                                      SMB0CN_STA = 1;                // By a START
 126   4                                      NUM_ERRORS++;           // Indicate error
 127   4                              }
 128   3                              break;
 129   3      
 130   3                              // Master Receiver: byte received
 131   3                      case SMB_MRDB:
 132   3                              SMB_DATA_IN = SMB0DAT;     // Store received byte
 133   3                              SMB_BUSY = 0;              // Free SMBus interface
 134   3                              SMB0CN_ACK = 0;                   // Send NACK to indicate last byte
 135   3                              SMB0CN_STO = 1;                   // Send STOP to terminate transfer
 136   3                              //UART_Send('a');
 137   3                              SMB0CN_STO = 1;             // Set SMB0CN_STO to terminate transfer
 138   3                              SMB_BUSY = 0;
 139   3                              break;
 140   3      
 141   3                      default:
 142   3                              FAIL = 1;                  // Indicate failed transfer
 143   3                              // and handle at end of ISR
 144   3                              break;
 145   3      
 146   3                      } // end switch
 147   2              }
 148   1              else
 149   1              {
 150   2                      // SMB0CN_ARBLOST = 1, error occurred... abort transmission
 151   2                      FAIL = 1;
 152   2              } // end SMB0CN_ARBLOST if
 153   1      
 154   1              if (FAIL)                           // If the transfer failed,
 155   1              {
 156   2                      SMB0CF &= ~0x80;                 // Reset communication
 157   2                      SMB0CF |= 0x80;
 158   2                      SMB0CN_STA = 0;
 159   2                      SMB0CN_STO = 0;
 160   2                      SMB0CN_ACK = 0;
 161   2      
 162   2                      SMB_BUSY = 0;                    // Free SMBus
 163   2      
 164   2                      FAIL = 0;
 165   2                      YELLOW_LED = LED_OFF;
 166   2      
 167   2                      NUM_ERRORS++;                    // Indicate an error occurred
 168   2              }
 169   1      
 170   1              SMB0CN_SI = 0;                             // Clear interrupt flag
 171   1      }
 172          
 173          
 174          //-----------------------------------------------------------------------------
 175          // TIMER3_ISR
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        04/08/2018 18:14:15 PAGE 4   

 176          //-----------------------------------------------------------------------------
 177          //
 178          // TIMER3 ISR Content goes here. Remember to clear flag bits:
 179          // TMR3CN::TF3H (Timer # High Byte Overflow Flag)
 180          // TMR3CN::TF3L (Timer # Low Byte Overflow Flag)
 181          //
 182          //-----------------------------------------------------------------------------
 183          INTERRUPT (TIMER3_ISR, TIMER3_IRQn)
 184          {
 185   1              SMB0CF &= ~0x80;                    // Disable SMBus
 186   1              SMB0CF |= 0x80;                     // Re-enable SMBus
 187   1              TMR3CN &= ~0x80;                    // Clear Timer3 interrupt-pending flag
 188   1              SMB0CN_STA = 0;
 189   1              SMB_BUSY = 0;                       // Free SMBus
 190   1      }
 191          
 192          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    204    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
