C51 COMPILER V9.53.0.0   F99X_SMBUS_MASTER                                                 04/15/2018 16:55:14 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE F99X_SMBUS_MASTER
OBJECT MODULE PLACED IN .\src\F99x_SMBus_Master.OBJ
COMPILER INVOKED BY: c:\SiliconLabs\SimplicityStudio\v4\developer\toolchains\keil_8051\9.53\BIN\C51.exe C:\Users\Rilind\
                    -Desktop\System_project\Exam_Project\Exam_Project_2\F99x-98x_SMBus_Master\src\F99x_SMBus_Master.c OMF2 SMALL DEBUG OBJECT
                    -EXTEND ROM(LARGE) WARNINGLEVEL(2) FLOATFUZZY(3) OPTIMIZE(8,SPEED) DEFINE(DEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(C:
                    -/Users/Rilind/Desktop/System_project/Exam_Project/Exam_Project_2/F99x-98x_SMBus_Master/inc;C:/SiliconLabs/SimplicityStud
                    -io/v4/developer/sdks/8051/v4.1.1//Device/shared/si8051base;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.1
                    -//Device/C8051F990/inc) PRINT(.\src\F99x_SMBus_Master.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\src\F99x_SMBus_Ma
                    -ster.OBJ)

line level    source

   1          //-----------------------------------------------------------------------------
   2          // F99x_SMBus_Master.c
   3          //-----------------------------------------------------------------------------
   4          // Copyright 2014 Silicon Laboratories, Inc.
   5          // http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   6          //
   7          // Program Description:
   8          //
   9          // Example software to demonstrate the SMBus interface in
  10          // Master mode.
  11          // - Interrupt-driven SMBus implementation
  12          // - Only master states defined (no slave or arbitration)
  13          // - 1-byte SMBus data holders used for each transmit and receive
  14          // - Timer1 used as SMBus clock source
  15          // - Timer3 used by SMBus for SCL low timeout detection
  16          // - SCL frequency defined by SMBus 0 module in Configurator
  17          // - SMB0CN_ARBLOST support included
  18          // - Pinout:
  19          //    P0.0 -> SDA (SMBus)
  20          //    P0.1 -> SCL (SMBus)
  21          //
  22          //    P1.3 -> YELLOW_LED
  23          //
  24          //    P2.7 -> C2D (debug interface)
  25          //
  26          //    all other port pins unused
  27          //
  28          // How To Test:
  29          //
  30          // 1) Verify that J13 and J14 are not populated.
  31          // 2) Ensure that jumpers are placed on the following:
  32          //       J11:  PWR/WALL_PWR
  33          //       J17:  VDD_PIN/PWR
  34          // 3) Connect the device to another 'Fxxx device running SMBus - Slave code.
  35          // 4) Connect the USB Debug Adapter to J4.
  36          // 5) Turn the POWER switch (SW5) to the "ON" position.
  37          // 6) Compile and download code to a 'F99x device on a C8051F99x-TB development
  38          //    board by selecting Run -> Debug from the menus, clicking the Debug button
  39          //    in the quick menu, or pressing F11.
  40          // 7) Run the code by selecting Run -> Resume from the menus, clicking the
  41          //    Resume button in the quick menu, or pressing F8:
  42          //         a) The test will indicate proper communication with the slave by
  43          //            toggling the YELLOW_LED on and off each time a value is sent and
  44          //            received.
  45          //         b) The best method to view the proper functionality is to run to
  46          //            the indicated line of code in the TEST CODE section of main and
  47          //            view the SMB_DATA_IN and SMB_DATA_OUT variables in the Watch
  48          //            Window.
  49          //
  50          //
C51 COMPILER V9.53.0.0   F99X_SMBUS_MASTER                                                 04/15/2018 16:55:14 PAGE 2   

  51          // Target:         C8051F99x-C8051F98x
  52          // Tool chain:     Simplicity Studio / Keil C51 9.51
  53          // Command Line:   None
  54          //
  55          // Release 1.1 (BL)
  56          //    - Updated Description / How to Test
  57          //    - 13 JAN 2014
  58          //
  59          // Release 1.0
  60          //    - Initial Revision (FB)
  61          //    - 19 MAY 2010
  62          //
  63          
  64          //-----------------------------------------------------------------------------
  65          // Includes
  66          //-----------------------------------------------------------------------------
  67          #include <compiler_defs.h>
  68          #include <SI_C8051F990_Register_Enums.h>                  // SFR declarations
  69          #include "InitDevice.h"
  70          #include "F99x_SMBus_Master.h"
  71          
  72          //-----------------------------------------------------------------------------
  73          // Global VARIABLES
  74          //-----------------------------------------------------------------------------
  75          U8 SMB_DATA_IN;                        // Global holder for SMBus data
  76          // All receive data is written here
  77          
  78          U8 SMB_DATA_OUT;
  79          U8 SMB_REG_OUT;
  80          U8 START_SMB;
  81          U8 RW_Reg; // Global holder for SMBus data.
  82          // All transmit data is read from here
  83          
  84          U8 TARGET;                             // Target SMBus slave address
  85          U8  par_g1;
  86          U16 par_g2;
  87          U8  par_g3;// Dummy variable counters
  88          U16 par_t1;
  89          int16_t par_t2;
  90          int8_t  par_t3;// Dummy variable counters
  91          uint32_t temp_adc;
  92          int16_t calc_temp;
  93          int16_t var1;
  94          int32_t var2;
  95          int16_t var3;
  96          int32_t t_fine;
  97          int32_t a;
  98          
  99          volatile bit SMB_BUSY;                 // Software flag to indicate when the
 100          // SMB_Read() or SMB_Write() functions
 101          // have claimed the SMBus
 102          
 103          volatile bit SMB_RW;                   // Software flag to indicate the
 104          // direction of the current transfer
 105          
 106          SBIT (SDA, SFR_P0, 0);                 // SMBus on P0.0
 107          SBIT (SCL, SFR_P0, 1);                 // and P0.1
 108          
 109          LOCATED_VARIABLE_NO_INIT (reserved, U8, SEG_XDATA, 0x0000);
 110          
 111          //-----------------------------------------------------------------------------
 112          // Function PROTOTYPES
 113          //-----------------------------------------------------------------------------
C51 COMPILER V9.53.0.0   F99X_SMBUS_MASTER                                                 04/15/2018 16:55:14 PAGE 3   

 114          
 115          void SMB_Write (void);
 116          void SMB_Read (void);
 117          void T0_Wait_ms (U8 ms);
 118          void SMB_Write_Reg(U8 Addr,U8 Reg, U8 Dat);
 119          U8 SMB_Read_Reg(U8 Addr, U8 Reg);
 120          void UART_Init(void);
 121          void UART_Send(char c);
 122          void print(char* string,U16 num);
 123          int16_t getTemp(void);
 124          
 125          
 126          //-----------------------------------------------------------------------------
 127          // SiLabs_Startup() Routine
 128          // ----------------------------------------------------------------------------
 129          // This function is called immediately after reset, before the initialization
 130          // code is run in SILABS_STARTUP.A51 (which runs before main() ). This is a
 131          // useful place to disable the watchdog timer, which is enable by default
 132          // and may trigger before main() in some instances.
 133          //-----------------------------------------------------------------------------
 134          void SiLabs_Startup (void)
 135          {
 136   1              // Disable the watchdog here
 137   1      }
 138          
 139          //-----------------------------------------------------------------------------
 140          // main() Routine
 141          // ----------------------------------------------------------------------------
 142          void UART_Init(void)
 143          {
 144   1              //baud rate=57600
 145   1              SCON0 = 0x50;  // Asynchronous mode, 8-bit data and 1-stop bit
 146   1              TMOD = 0x20;  //Timer1 in Mode2.
 147   1              // TH1 = 256 - (24500000UL)/(long)(32*12*baudrate); // Load timer value for baudrate generation
 148   1              TH1 = (0x2B << TH1_TH1__SHIFT);
 149   1              TCON |= (1<<6);      //Turn ON the timer for Baud rate generation
 150   1      }
 151          
 152          void UART_Send(char c)
 153          {
 154   1              SBUF0 = c;      // Load the data to be transmitted
 155   1              while(SCON0_TI==0);   // Wait till the data is trasmitted
 156   1              SCON0_TI = 0;
 157   1      }
 158          void print(char* string,U16 num)
 159          {
 160   1              char c=0;
 161   1              char s[10];
 162   1              int8_t j=0;
 163   1              int8_t i=0;
 164   1              U8 len = 0;
 165   1              while ((c=(*(string++))) != '\0') {
 166   2                      UART_Send(c);
 167   2                      len++;
 168   2              }
 169   1              for(;j<10;j++){
 170   2                      *(string++)=(num%10)+'0';
 171   2                      s[j]=((num%10)+'0');
 172   2                      num=num/10;
 173   2                      if(num==0)
 174   2                      break;
 175   2              }
 176   1              for(i=(j);i>=0;i--)
C51 COMPILER V9.53.0.0   F99X_SMBUS_MASTER                                                 04/15/2018 16:55:14 PAGE 4   

 177   1              {
 178   2                      UART_Send(s[i]);
 179   2              }
 180   1              UART_Send('\r');
 181   1              //UART_Send('\n');
 182   1      
 183   1      }
 184          U8 SMB_Read_Reg(U8 Addr, U8 Reg)
 185          {
 186   1              RW_Reg=0;
 187   1              TARGET = Addr;
 188   1              SMB_REG_OUT = Reg;
 189   1              START_SMB=1;// Define next outgoing byte
 190   1              SMB_Write();                     // Initiate SMBus write
 191   1              START_SMB=1;
 192   1              TARGET = Addr|0x01;             // Target the F3xx/Si8250 Slave for next                                                                   // SMBus transfer
 193   1              SMB_Read();
 194   1              return SMB_DATA_IN;
 195   1      }
 196          
 197          void SMB_Write_Reg(U8 Addr,U8 Reg, U8 Dat)
 198          {
 199   1              RW_Reg=1;
 200   1              TARGET = Addr;             // Target the F3xx/Si8250 Slave for next
 201   1              START_SMB=1;
 202   1              SMB_DATA_OUT = Dat;
 203   1              SMB_REG_OUT = Reg;// SMBus transfer
 204   1              SMB_Write();
 205   1      
 206   1              while(SMB_BUSY){
 207   2                      ;;
 208   2              }
 209   1      
 210   1      }
 211          int16_t getTemp(void)
 212          {
 213   1              temp_adc=((uint32_t)(SMB_Read_Reg(0xEE,0x22))<<12)|((SMB_Read_Reg(0xEE,0x23)<<4));
 214   1              var1 = ((int32_t)temp_adc >> 3) - ((int32_t)par_t1 << 1);
 215   1              var2 = (var1 *  (int32_t)par_t2) >> 11;
 216   1              var3 = ((var1 >> 1) * (var1 >> 1)) >> 12;
 217   1              var3 = ((var3) * ((int32_t)par_t3 << 4)) >> 14;
 218   1              t_fine =(int32_t)(var2 + var3);
 219   1      
 220   1              calc_temp =(((t_fine * 5) + 128) >> 8);
 221   1              calc_temp/=100;
 222   1              return calc_temp;
 223   1      }
 224          
 225          int main (void)
 226          {
 227   1              U8  i;
 228   1              //Enter default mode
 229   1              enter_DefaultMode_from_RESET();
 230   1              //printf("%d",0x22);
 231   1              // If slave is holding SDA low because of an improper SMBus reset or error
 232   1              while(!SDA)
 233   1              {
 234   2                      // Provide clock pulses to allow the slave to advance out
 235   2                      // of its current state. This will allow it to release SDA.
 236   2                      XBR2 = 0x40;                     // Enable Crossbar
 237   2                      SCL = 0;                         // Drive the clock low
 238   2                      for(i = 0; i < 255; i++);        // Hold the clock low
 239   2                      SCL = 1;                         // Release the clock
C51 COMPILER V9.53.0.0   F99X_SMBUS_MASTER                                                 04/15/2018 16:55:14 PAGE 5   

 240   2                      while(!SCL);                     // Wait for open-drain
 241   2                      // clock output to rise
 242   2                      for(i = 0; i < 10; i++);         // Hold the clock high
 243   2                      XBR2 = 0x00;                     // Disable Crossbar
 244   2              }
 245   1      
 246   1              enter_Mode2_from_DefaultMode();
 247   1              UART_Init();
 248   1      
 249   1              //SMB_Write_Reg(0x30,0x20,0x37);
 250   1      
 251   1              SMB_Write_Reg(0xEE,0xE0,0xB6);// reset
 252   1              SMB_Write_Reg(0xEE,0x72,0x01);// hum:1x
 253   1              SMB_Write_Reg(0xEE,0x74,0x25);// temp:8x, pressure:8x
 254   1      
 255   1              par_g1=SMB_Read_Reg(0xEE,0xED);
 256   1              par_g2=(SMB_Read_Reg(0xEE,0xEC)<<8)|SMB_Read_Reg(0xEE,0xEB);
 257   1              par_g3 =SMB_Read_Reg(0xEE,0xEE);
 258   1      
 259   1              //par_t1=(SMB_Read_Reg(0xEE,0xEA)<<8)|SMB_Read_Reg(0xEE,0xE9);
 260   1              //par_t2=(SMB_Read_Reg(0xEE,0x8B)<<8)|SMB_Read_Reg(0xEE,0x8A);
 261   1              //par_t3 =SMB_Read_Reg(0xEE,0x8C);
 262   1              par_t1=26487;
 263   1              par_t2=26223;
 264   1              par_t3 =3;
 265   1              //SMB_Write_Reg(0xEE,0x64,0x59);// 100ms heatup
 266   1              while (1)
 267   1              {
 268   2                      SMB_Write_Reg(0xEE,0x74,0x25);// trigger forced mode
 269   2      
 270   2                      print("Temp: ",getTemp());
 271   2                      print("--------",0);
 272   2      
 273   2                      YELLOW_LED = !YELLOW_LED;
 274   2      
 275   2                      for(a=0;a<100000;a++){
 276   3                              ;;
 277   3                              // Wait 50 ms until the next cycle
 278   3                      }
 279   2      
 280   2              }
 281   1      
 282   1              return 0;
 283   1      }
 284          
 285          //-----------------------------------------------------------------------------
 286          // Support Functions
 287          //-----------------------------------------------------------------------------
 288          
 289          //-----------------------------------------------------------------------------
 290          // SMB_Write
 291          //-----------------------------------------------------------------------------
 292          //
 293          // Return Value : None
 294          // Parameters   : None
 295          //
 296          // Writes a single byte to the slave with address specified by the <TARGET>
 297          // variable.
 298          // Calling sequence:
 299          // 1) Write target slave address to the <TARGET> variable
 300          // 2) Write outgoing data to the <SMB_DATA_OUT> variable
 301          // 3) Call SMB_Write()
 302          //
C51 COMPILER V9.53.0.0   F99X_SMBUS_MASTER                                                 04/15/2018 16:55:14 PAGE 6   

 303          //-----------------------------------------------------------------------------
 304          void SMB_Write (void)
 305          {
 306   1              while (SMB_BUSY);                   // Wait for SMBus to be free.
 307   1              SMB_BUSY = 1;                       // Claim SMBus (set to busy)
 308   1              SMB_RW = 0;                         // Mark this transfer as a WRITE
 309   1              SMB0CN_STA = 1;                            // Start transfer
 310   1      }
 311          
 312          //-----------------------------------------------------------------------------
 313          // SMB_Read
 314          //-----------------------------------------------------------------------------
 315          //
 316          // Return Value : None
 317          // Parameters   : None
 318          //
 319          // Reads a single byte from the slave with address specified by the <TARGET>
 320          // variable.
 321          // Calling sequence:
 322          // 1) Write target slave address to the <TARGET> variable
 323          // 2) Call SMB_Write()
 324          // 3) Read input data from <SMB_DATA_IN> variable
 325          //
 326          //-----------------------------------------------------------------------------
 327          void SMB_Read (void)
 328          {
 329   1              while (SMB_BUSY != 0);               // Wait for transfer to complete
 330   1              SMB_BUSY = 1;                       // Claim SMBus (set to busy)
 331   1              SMB_RW = 1;                         // Mark this transfer as a READ
 332   1      
 333   1              SMB0CN_STA = 1;                            // Start transfer
 334   1      
 335   1              while (SMB_BUSY);                   // Wait for transfer to complete
 336   1      }
 337          
 338          //-----------------------------------------------------------------------------
 339          // T0_Wait_ms
 340          //-----------------------------------------------------------------------------
 341          //
 342          // Return Value : None
 343          // Parameters   :
 344          //   1) U8 ms - number of milliseconds to wait
 345          //                        range is full range of character: 0 to 255
 346          //
 347          // Configure Timer0 to wait for <ms> milliseconds using SYSCLK as its time
 348          // base.
 349          //
 350          //-----------------------------------------------------------------------------
 351          void T0_Wait_ms (U8 ms)
 352          {
 353   1      
 354   1              while (ms) {
 355   2                      TCON_TR0 = 0;                         // Stop Timer0
 356   2                      TH0 = ((-(SYSCLK/1000)) >> 8);   // Overflow in 1ms
 357   2                      TL0 = ((-(SYSCLK/1000)) & 0xFF);
 358   2                      TCON_TF0 = 0;                         // Clear overflow indicator
 359   2                      TCON_TR0 = 1;                         // Start Timer0
 360   2                      while (!TCON_TF0);                    // Wait for overflow
 361   2                      ms--;                            // Update ms counter
 362   2              }
 363   1      
 364   1              TCON_TR0 = 0;                            // Stop Timer0
 365   1      }
C51 COMPILER V9.53.0.0   F99X_SMBUS_MASTER                                                 04/15/2018 16:55:14 PAGE 7   

 366          
 367          //-----------------------------------------------------------------------------
 368          // End Of File
 369          //-----------------------------------------------------------------------------
*** WARNING C294 IN LINE 282 OF C:\Users\Rilind\Desktop\System_project\Exam_Project\Exam_Project_2\F99x-98x_SMBus_Master
             -\src\F99x_SMBus_Master.c: unreachable code


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    803    ----
   CONSTANT SIZE    =     16    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     37      18
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
